# -*- coding: utf-8 -*-
"""Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UDHv0R4HbfyUpJk0P9ZnE3DT6hLl276A
"""

#Importing Libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score

#Loading dataset(importing data)
monuments=pd.read_csv("C:/Users/meena/OneDrive/Desktop/AI/monuments.csv")

#Converting into dataframe
monuments_df=pd.DataFrame(monuments)

#Print dataframe
monuments_df

#Information
monuments_df.info()

#shape
monuments_df.shape

#Head
monuments_df.head()

#Describing dataset
monuments_df.describe()

#including obejct
monuments_df.describe(include='object')

#Checking Null values
monuments_df.isnull().sum()

"""#**Data Visualization**"""

#ALL PLOTS
sns.set_style("whitegrid")

fig, axes = plt.subplots(3, 2, figsize=(15, 15))

#1.Dynasty
monuments['Dynasty'].value_counts().plot(
    kind='barh', color='skyblue', ax=axes[0,0]
)
axes[0,0].set_xlabel("Number of Monuments")
axes[0,0].set_ylabel("Dynasty")
axes[0,0].set_title("Distribution by Dynasty", color='darkblue')

#2.Year Built
monuments['Year_Built'].plot(
    kind='hist', bins=20, color='lightgreen', ax=axes[0,1]
)
axes[0,1].set_xlabel("Year Built")
axes[0,1].set_ylabel("Number of Monuments")
axes[0,1].set_title("Distribution by Year Built", color='darkgreen')

#3.Patron / Ruler (Top 10)
top_patrons = monuments['Patron_Ruler'].value_counts().head(10)
top_patrons.plot(kind='barh', color='orange', ax=axes[1,0])
axes[1,0].set_xlabel("Number of Monuments")
axes[1,0].set_ylabel("Patron / Ruler")
axes[1,0].set_title("Top 10 Patrons / Rulers", color='darkorange')

#4.UNESCO Status
monuments['UNESCO_Status'].value_counts().plot(
    kind='pie', autopct='%1.1f%%', colors=['lightgreen','lightcoral','skyblue'],
    ax=axes[1,1]
)
axes[1,1].set_ylabel("")  # remove y-label
axes[1,1].set_title("UNESCO Status Distribution", color='purple')

#5.Architectural Style (Top 10)
top_styles = monuments['Architectural_Style'].value_counts().head(10)
top_styles.plot(kind='barh', color='teal', ax=axes[2,0])
axes[2,0].set_xlabel("Number of Monuments")
axes[2,0].set_ylabel("Architectural Style")
axes[2,0].set_title("Top 10 Architectural Styles", color='teal')

#6.Monument Type
monuments['Monument_Type'].value_counts().plot(kind='barh', color='pink', ax=axes[2,1])
axes[2,1].set_xlabel("Number of Monuments")
axes[2,1].set_ylabel("Type")
axes[2,1].set_title("Distribution of Monument Types", color='red')

plt.tight_layout()
plt.show()

#columns
monuments_df.columns

#Feature selection
x=monuments_df[['Monument_Type','Year_Built','Patron_Ruler','State','Architectural_Style','Material','Religion']]

#x as a separate dataframe
x_df=pd.DataFrame(x)

#output as a separate dataframe
y_df=pd.DataFrame(monuments_df['Dynasty'])

x_df

y_df

#Checking unique values for dynasty
monuments['Dynasty'].unique()

#Converting categorical into numerical (encoding)
label = LabelEncoder()
monuments['Dynasty_Label'] = label.fit_transform(monuments['Dynasty'])

#Checking unique values after encoding
monuments['Dynasty_Label'].unique()

#Checking original + Encoded
monuments[['Dynasty', 'Dynasty_Label']].head(15)

#Print full mapping (encoded number for the dynasty)
for cls, val in zip(label.classes_, label.transform(label.classes_)):
    print(cls, "-", val)

#check columns
monuments.columns

#To remove the original column of dynasty (categorical)
monuments = monuments.drop('Dynasty', axis=1)

#Info
monuments.info()

#Encoding categorical columns selected for features
cat_features = ['Monument_Type', 'Patron_Ruler', 'State',
                'Architectural_Style', 'Material', 'Religion']

for col in cat_features:
    le = LabelEncoder()
    monuments[col + "_Label"] = le.fit_transform(monuments[col])

#drop the categorical columns
monuments = monuments.drop(cat_features, axis=1)

#info
monuments.info()

#drop unnecssary columns
drop_cols = ['City', 'UNESCO_Status', 'Purpose']
# Drop the columns
monuments = monuments.drop(drop_cols, axis=1)

#Columns
monuments.columns

# Features and target
x = monuments[['Monument_Type_Label','Year_Built','Patron_Ruler_Label','State_Label','Architectural_Style_Label','Material_Label','Religion_Label']]
y = monuments['Dynasty_Label']

#Splitting data into train and test sets
x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=42)

#Using random forest
rf_model = RandomForestClassifier(n_estimators=200, random_state=42)
rf_model.fit(x_train, y_train)

#Prediction
y_pred = rf_model.predict(x_test)

#Evaluating Model
#Check Accuracy
print("Accuracy:", accuracy_score(y_test, y_pred))

#Classification Report
print("\nClassification Report:\n", classification_report(y_test, y_pred))

#Confusion Matrix
print("\nConfusion Matrix:\n", confusion_matrix(y_test, y_pred))

#columns
monuments.columns

from sklearn.preprocessing import LabelEncoder

# Columns that are label encoded (change if needed)
categorical_cols = [
    'Monument_Type',
    'Patron_Ruler',
    'State',
    'Architectural_Style',
    'Material',
    'Religion',
    'Dynasty'
]

print("====== CATEGORY MAPPING TABLES ======\n")

# Dictionary to store encoders if needed
encoders = {}

for col in categorical_cols:
    le = LabelEncoder()
    le.fit(monuments_df[col])   # fit on ORIGINAL categorical column

    encoders[col] = le   # save encoder

    print(f"\nMapping for {col}:")
    for i, label in enumerate(le.classes_):
        print(f"{i}   {label}")

#Print year built column
monuments['Year_Built']

#Encoded numbers
#Monument type(0-13)
#Patron ruler(0-13)
#State(0-13)
#Architectrual style(0-9)
#Material(0-6)
#Religion(0-5)

#User input
mon_type = int(input("Enter Monument_Type_Label: "))
year_built = int(input("Enter Year_Built: "))
patron = int(input("Enter Patron_Ruler_Label: "))
state = int(input("Enter State_Label: "))
arch_style = int(input("Enter Architectural_Style_Label: "))
material = int(input("Enter Material_Label: "))
religion = int(input("Enter Religion_Label: "))

input_df = pd.DataFrame([{
    'Monument_Type_Label': mon_type,
    'Year_Built': year_built,
    'Patron_Ruler_Label': patron,
    'State_Label': state,
    'Architectural_Style_Label': arch_style,
    'Material_Label': material,
    'Religion_Label': religion
}])

pred_label = rf_model.predict(input_df)[0]

predicted_dynasty = encoders['Dynasty'].inverse_transform([pred_label])[0]

print("\nPredicted Dynasty:", predicted_dynasty)
